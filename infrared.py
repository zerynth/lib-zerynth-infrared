"""
.. module:: infrared

*****************
Infra Red Library
*****************

Infra Red Capture, Send and Decode module

This module contains class definitions and methods to capture, decode and send IR packets.

* The IRPacket class allows the definition of IRPacket objects.
* The IRReceiver class allows the definition of an IR capture unit based on an IR receiver and demodulator connected to a pin empowered with ICU feature.
* The IRSender class allows the definition of an IR sender based on an IR LED connected to a pin endowed with PWM feature.
"""

import icu
import pwm
import hwtimers

class IRPacket():
    """
    ==================
    IRPacket class
    ==================
    
    .. class:: IRPacket(packet_type, addr1, addr2, d1, d2, hexd, rawdata, databits)
    
        This is the class that allows the definition of IR messages/packets  

        Attributes:

            * packet_type: it is a string identifying the packet IR protocol of the message. Currently the following packets are supported: SAMSUNG, NEC and UNKNOWN.
            * addr1: it is the first address data packet (to be set to 0 if not supported by the selected protocol)
            * addr2: it is the second address data packet (to be set to 0 if not supported by the selected protocol)
            * d1: it is the first message data packet
            * d2: it is the second message data packet (to be set as 0 if not supported by the selected protocol)
            * hexd: it is the Hexadecimal string representing the data contained in d1 and d2
            * rawdata: it is a list of int containing the raw data acquired by the transducer during the acquisition of the packet. Data are listed as int representing the duration in microseconds of a "pulse state" the first reported time is an HIGH pulse duration, the second is the duration of the following LOW pulse and so on.
            * databits: is a list of strings "0" or "1" representing the boolean decode of rawdata obtained through the decoder selected according to the packet_type  
        
        IrPacket instances are generated by the infrared.decode() and are taken as input by the IRSender.send() methods.
        
    """


    def __init__(self,packet_type,addr1, addr2,d1,d2,hexd,rawdata,databits):
        self.packetType=packet_type
        self.addres1=addr1
        self.addres2=addr2
        self.data1=d1
        self.data2=d2
        self.hexdata=hexd 
        self.raw=rawdata
        self.bits=databits
    
    

    def printPacket(self,s):
        """
        .. method:: printPacket(stream)

            generates a Print-friendly and readable output containing the packet data and print it on the selected stream.
        """
        print("packetType:",self.packetType,stream=s)
        print("Address1:",self.addres1,stream=s)
        print("Address2:",self.addres2,stream=s)
        print("Data1:",self.data1,stream=s)
        print("Data2:",self.data2,stream=s)
        print("HEX:",self.hexdata,stream=s)
        print("RAW:",self.raw,stream=s)
        print("DataBITs:",self.bits,stream=s)
        print("-"*30)   

    
class IRReceiver():

    """
    ==================
    IRReceiver class
    ==================
    
    .. class:: IRReceiver(IrRecvPin)
    
        This is the class that allows definition of an IR receivers made by using an IR demodulator.
            
        *IrRecvPin*: The pin connected with the IR demodulator. The pin have to be endowed with ICU functionality and passed using the Dx.ICU signature.
    """

    def __init__(self,IrRecvPin):
        self.pin = IrRecvPin


    def to_samsung_times(self,x):
            res, times = [], [590,1690,4500]
            for i in x:
                for t in times:
                    if abs(i-t) < 200:
                        res.append(t)
                        break
            return res

    def to_nec_times(self,x):
        res, times = [], [560,1690,4500,9000]
        for i in x:
            for t in times:
                if abs(i-t) < 200:
                    res.append(t)
                    break
        return res


    def decodeSamsung(self,data):
        result=[]
        data1=0
        data2=0
        databits=[]
        x= self.to_samsung_times(data)
        for i in range(2,32,2):            
            if x[i]==590:  #ok this is the start of a bit
                if x[i+1]==590:  #this is a ZERO 
                    databits.append("0")
                    data1=data1
                elif x[i+1]==1690: #this is a ONE                
                    databits.append("1")
                    data1=data1+1
            data1=2*data1    
            
        for i in range(34,64,2):            
            if x[i]==590:  #ok this is the start of a bit
                if x[i+1]==590:  #this is a ZERO
                    databits.append("0")
                    data2=data2
                elif x[i+1]==1690: #this is a ONE
                    databits.append("1")
                    data2=data2+1
            data2=2*data2        

        
        if x[66]==590:
            databits.append("1")
            data2=data2+1
        HEX=hex(data1,prefix="")+hex(data2,prefix="")
        
        return IRPacket("Samsung",0,0,data1,data2,HEX,x,databits)

    def decodeNec(self,data):
        result=[]
        addres1=0
        addres2=0
        data1=0
        data2=0
        databits=[]
        x= self.to_nec_times(data)
        for i in range(2,32,2):            
            if x[i]==560:  #ok this is the start of a bit
                if x[i+1]==560:  #this is a ZERO                
                    databits.append("0")
                    data1=data1
                elif x[i+1]==1690: #this is a ONE
                    databits.append("1")
                    data1=data1+1
            data1=2*data1

        
        for i in range(34,64,2):            
            if x[i]==560:  #ok this is the start of a bit
                if x[i+1]==1690:  #this is a ZERO
                    databits.append("0")
                    data2=data2
                elif x[i+1]==1690: #this is a ONE
                    databits.append("1")
                    data2=data2+1
            data2=2*data2        

        
        if x[66]==560:
            databits.append("1")
            data2=data2+1
        HEX=hex(data1,prefix="")+hex(data2,prefix="")
        
        return IRPacket("NEC",0,0,data1,data2,HEX,x,databits)

    
       

    def decode(self,x): 
        """
        .. method:: decode(data)

            Analyzes the raw captured data identifying the protocol.

            If the protocol is recognized data are decoded and an IRPacket returned.
            Otherwise an IRPacket with packet_type "UNKNOWN" is returned
        """
        if len(x)>66 and abs(4500-x[0])<200 and abs(4500-x[1])<200 :  #ok we have a Samsung data packet
            packet=self.decodeSamsung(x)
        
        elif len(x)>52 and abs(9000-x[0])<200 and abs(4500-x[1])<200 :  #ok we have a NEC data packet
            packet=self.decodeNec(x)
        else:
            
            packet=IRPacket("Unknown",0,0,0,0,"000000",x,[])
        return packet    
               



   
    
    def capture(self,max_samples=100,time_window=200,wait=0):
        """
        .. method:: capture(max_samples=100,time_window=200,wait=0)

            Starts the IR capture activating the ICU on the receiver pin.

        
            * max_samples: it sets the number of samples to be collected before terminate the capture. Default is set to 100 that works for most of the used IR protocols.
            * time_window: it sets the max amount in milliseconds of the capture window. Default is set to 200 milliseconds that works for most of the used IR protocols. 
            * wait: it allows the definition of a sleeping time in millisecond to be waited after a capture in order to avoid capturing repeated packets as partial raw data.
        
            Consider that air conditioning remote controller IR packets are very long therefore these values have to be tuned according to the desired application.  
            
            The method returns raw captured data packet that can be used as input for IRSender.sendRaw() or decoded using IRReceiver.decode()
        """
        x=icu.capture(self.pin,LOW,max_samples,time_window,pull=HIGH)
        if wait!=0:
            sleep(wait)
        return x

    
    
    def captureAndDecode(self,max_samples=100,time_window=200,wait=0):
        """
        .. method:: captureAndDecode(max_samples=100,time_window=200,wait=0)

            Starts the IR capture activating the ICU on the receiver pin and pass the captured raw signal to the decode method returning an IRPacket
            
            * max_samples: it sets the number of samples to be collected before terminate the capture. Default is set to 100 that works for most of the used IR protocols.
            * time_window: it sets the max amount in milliseconds of the capture window. Default is set to 200 milliseconds that works for most of the used IR protocols. 
            * wait: it allows the definition of a sleeping time in millisecond to be waited after a capture in order to avoid capturing repeated packet as partial raw data.
     
            Consider that air conditioning remote controller IR packets are very long therefore these values have to be tuned according tot the desired application.  
            
            The method returns an IRPacket.       
        """
        x=icu.capture(self.pin,LOW,max_samples,time_window,pull=HIGH)
        if wait!=0:
            sleep(wait)
        return self.decode(x)
      
    
    


class IRSender():
    """
    ==================
    IRSender class
    ==================

    .. class:: IRSender(IRSenderPin,Frequency=38000,Duty=30)

        This is the class that allows the definition of an IR sender made by connecting and IR LED to a pin endowed with PWM.
        
        * IRSenderPin: it is the pin where the LED is connected. Have to be passed specifying the PWM feature i.e, D3.PWM
        * Frequency: it is the IR pulse modulation frequency. default is set to 38000 Hz that is the most used standard.
        * Duty: It is the duration in percentage 0-100 of the IR pulse. The duty definition allows reducing power consumption avoiding long pulses. Default is set to 30 while values in the range 20-50 can be used. 

        The class has two methods for sending respectively raw data and IRPacket.
    """
    def __init__(self,IRSenderPin,Frequency=38000,Duty=30):
        self.period=1000000//Frequency
        self.duty=self.period*Duty//100
        self.senderPin=IRSenderPin

    
            
    def sendRaw(self,x):
        """
        .. method:: sendRaw(data)

            Sends raw data by taking as input a list of pulses duration in microseconds. The first represents the duration of IR firing phase (state 1) while the the second is the IR LED  OFF phase (state 0) and so on.
       
        """
    
        state = 1
        for pulse in x: 
            npulse=pulse//self.period
            #print("npulse",npulse)
            if state:
                pwm.write(self.senderPin,self.period,self.duty,MICROS,npulse)
            else:
                hwtimers.sleep_micros(pulse)
            state = state^1


            
    def send(self,x):
        """
        .. method:: send(IRPacket)

            Sends the IR message contained in the passed IRPacket. If IRPacket packet_type is UNKNOWN data are sent as raw data.
       
        """        
    
        self.sendRaw(x.raw)